{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"jQuery\"","webpack:///./js/Menu.js","webpack:///./js/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","jQuery","ESC_KEY","END_KEY","HOME_KEY","LEFT_ARROW","UP_ARROW","RIGHT_ARROW","DOWN_ARROW","HOVER_ENTER_TIMEOUT","HOVER_MOVE_TIMEOUT","HOVER_LEAVE_TIMEOUT","lastSubmenuIndex","Menu_MenuItem","[object Object]","menu","$element","this","$link","find","first","open","attr","$submenuElement","length","submenuIndex","generateSubmenuId","submenu","role","focusContainer","addClass","$toggle","external_jQuery_default","insertAfter","text","update","setOpenIndex","removeClass","expanded","is","focus","js_Menu","options","hoverTimeout","hoverMoveTimeout","items","openIndex","hoverMode","hoverIntent","focusin","event","$activeElement","target","setActiveElement","setOrientation","document","on","has","keydown","which","item","stopPropagation","preventDefault","mouseenter","setHoverMode","children","each","index","itemElement","$itemElement","push","openKey","orientation","closeKey","prevKey","nextKey","focusFirstItem","prevItem","nextItem","firstItem","lastItem","clearTimeout","undefined","setTimeout","mousemove","mouseleave","click","$prevActiveElement","$nextActiveElement","firstOffset","offset","secondOffset","dx","Math","abs","left","dy","top","some","forEach","setOpen","a","fn","slMenu","ready"],"mappings":"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","file":"menu.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = jQuery;","import $ from 'jquery';\n\nconst ESC_KEY = 27;\nconst END_KEY = 35;\nconst HOME_KEY = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\n\nconst HOVER_ENTER_TIMEOUT = 400;\nconst HOVER_MOVE_TIMEOUT = 40;\nconst HOVER_LEAVE_TIMEOUT = 400;\n\nlet lastSubmenuIndex = 0;\n\nfunction generateSubmenuId() {\n  const submenuIndex = lastSubmenuIndex + 1;\n  lastSubmenuIndex = submenuIndex;\n  return `sl-menu__submenu_${submenuIndex}`;\n}\n\nclass MenuItem {\n  constructor(menu, $element) {\n    this.menu = menu;\n    this.$element = $element;\n    // Allow the link to be in a wrapper for styling purposes.\n    this.$link = $element.find('a').first();\n    this.open = false;\n\n    if (!this.$element.attr('role')) {\n      this.$element.attr('role', 'none');\n    }\n    if (!this.$link.attr('role')) {\n      this.$link.attr('role', 'menuitem');\n    }\n\n    const $submenuElement = $element.find('ul').first();\n    if ($submenuElement.length) {\n      if (!$submenuElement.attr('id')) {\n        $submenuElement.attr('id', generateSubmenuId());\n      }\n\n      this.submenu = new (menu.constructor)($submenuElement, {\n        role: 'menu',\n        focusContainer: false,\n      });\n      this.$element.addClass('sl-menu--has-submenu');\n      this.$link\n        .attr('aria-haspopup', 'menu')\n        .attr('aria-controls', $submenuElement.attr('id'));\n      this.$toggle = $('<button type=\"button\" class=\"sl-menu__toggle\">Toggle menu</button>')\n        .attr('aria-controls', $submenuElement.attr('id'))\n        .attr('tabindex', '-1')\n        // If the link is in a wrapper, this puts the toggle button in the wrapper for easier\n        // styling.\n        .insertAfter(this.$link);\n      $submenuElement.addClass('sl-menu__submenu');\n      if (!$submenuElement.attr('aria-label')) {\n        $submenuElement.attr('aria-label', this.$link.text());\n      }\n    }\n\n    this.update();\n  }\n\n  setOpen(open) {\n    if (!this.submenu) {\n      return;\n    }\n\n    this.open = open;\n    // Recursively close any submenus.\n    this.submenu.setOpenIndex(-1);\n\n    this.update();\n  }\n\n  update() {\n    if (!this.submenu) {\n      return;\n    }\n\n    if (this.open) {\n      this.$element.removeClass('sl-menu--closed');\n      this.$element.addClass('sl-menu--open');\n    } else {\n      this.$element.removeClass('sl-menu--open');\n      this.$element.addClass('sl-menu--closed');\n    }\n\n    // Set aria-expanded based on how these classes affect styling. These classes may not have an\n    // effect depending on responsive breakpoints.\n    // TODO: Efficiently listen for window resize events and update this attribute when breakpoints\n    // change.\n    const expanded = this.submenu.$element.is(':visible') ? 'true' : 'false';\n    this.$link.attr('aria-expanded', expanded);\n    this.$toggle.attr('aria-expanded', expanded);\n  }\n\n  focus() {\n    this.$link.focus();\n  }\n}\n\nclass Menu {\n  constructor($element, options = {}) {\n    this.$element = $element;\n    // Indicates our ARIA role, typically menubar for the root menu and menu for submenus.\n    this.role = options.role || 'menubar';\n    // Determines whether we are the root menu and therefore the focus container that manages the\n    // roving tabindex.\n    this.focusContainer = typeof options.focusContainer === 'boolean' ? options.focusContainer : true;\n    this.items = [];\n    this.openIndex = -1;\n    this.hoverMode = true;\n    this.hoverIntent = false;\n\n    if (!this.$element.attr('role')) {\n      this.$element.attr('role', this.role);\n    }\n\n    // Triggered when any descendant receives focus.\n    $element.focusin((event) => {\n      // Update the roving tabindex.\n      if (this.focusContainer) {\n        const $activeElement = $(event.target);\n        this.setActiveElement($activeElement);\n      }\n\n      // Detect our orientation so our keyboard navigation make sense.\n      this.setOrientation();\n    });\n\n    if (this.focusContainer) {\n      // The focusout event is unreliable across browsers, operating systems, front-end test\n      // frameworks, etc. so instead check whether an element that is not a descendant has received\n      // a focus-changing event.\n      $(document).on('keypress click focusin', (event) => {\n        if (this.openIndex !== -1 && $element.has(event.target).length === 0) {\n          this.setActiveElement(this.items[this.openIndex].$link);\n          this.setOpenIndex(-1);\n        }\n      });\n    }\n\n    // Close submenu when Escape key is pressed.\n    $element.keydown((event) => {\n      if (event.which === ESC_KEY && this.openIndex !== -1) {\n        const item = this.items[this.openIndex];\n        this.setOpenIndex(-1);\n        item.focus();\n\n        // Close one submenu at a time.\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    });\n\n    // Detect whether hover mode should be enabled.\n    $element.mouseenter(() => {\n      this.setHoverMode();\n    });\n\n    let hoverTimeout;\n    let hoverMoveTimeout;\n    $element.children('li').each((index, itemElement) => {\n      const $itemElement = $(itemElement);\n      const item = new MenuItem(this, $itemElement);\n      this.items.push(item);\n\n      // Set up all menu item links for roving tabindex.\n      item.$link.attr('tabindex', '-1');\n\n      $itemElement.keydown((event) => {\n        // Determine the keys for different behaviors based on our orientation.\n        const openKey = this.orientation === 'horizontal' ? DOWN_ARROW : RIGHT_ARROW;\n        const closeKey = this.orientation === 'horizontal' ? UP_ARROW : LEFT_ARROW;\n        const prevKey = this.orientation === 'horizontal' ? LEFT_ARROW : UP_ARROW;\n        const nextKey = this.orientation === 'horizontal' ? RIGHT_ARROW : DOWN_ARROW;\n\n        switch (event.which) {\n          case openKey:\n            if (item.submenu && this.openIndex !== index) {\n              this.setOpenIndex(index);\n              item.submenu.focusFirstItem();\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case closeKey:\n            if (item.submenu && this.openIndex === index) {\n              this.setOpenIndex(-1);\n              item.focus();\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case prevKey:\n            if (index > 0) {\n              // Determine whether this event bubbled up from an open submenu.\n              const bubbled = index === this.openIndex;\n\n              // Only allow bubbling from an open submenu on a horizontal menu.\n              if (!bubbled || this.orientation === 'horizontal') {\n                const prevItem = this.items[index - 1];\n\n                // If a submenu is open, try to open the previous item's submenu.\n                if (prevItem.submenu && this.openIndex !== -1) {\n                  this.setOpenIndex(index - 1);\n                  prevItem.submenu.focusFirstItem();\n                } else {\n                  this.setOpenIndex(-1);\n                  prevItem.focus();\n                }\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case nextKey:\n            if (index < this.items.length - 1) {\n              const nextItem = this.items[index + 1];\n\n              // If a submenu is open, try to open the previous item's submenu.\n              if (nextItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(index + 1);\n                nextItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                nextItem.focus();\n              }\n            }\n\n            // We're at the end of the menu, don't allow this to bubble and close the menu or\n            // something.\n            event.stopPropagation();\n            event.preventDefault();\n            break;\n\n          case HOME_KEY:\n            if (this.items.length > 0) {\n              const firstItem = this.items[0];\n\n              // If a submenu is open, try to open the first item's submenu.\n              if (firstItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(1);\n                firstItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                firstItem.focus();\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case END_KEY:\n            if (this.items.length > 0) {\n              const lastItem = this.items[this.items.length - 1];\n\n              // If a submenu is open, try to open the last item's submenu.\n              if (lastItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(this.items.length - 1);\n                lastItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                lastItem.focus();\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          default:\n            // Ignore all other keys.\n        }\n      });\n\n      $itemElement.mouseenter(() => {\n        if (!this.hoverMode) {\n          return;\n        }\n\n        if (hoverTimeout) {\n          clearTimeout(hoverTimeout);\n          hoverTimeout = undefined;\n        }\n        if (this.hoverIntent) {\n          this.setOpenIndex(index);\n        } else {\n          // Assume hover intent HOVER_ENTER_TIMEOUT after the mouse enters.\n          hoverTimeout = setTimeout(() => {\n            if (!this.hoverMode) {\n              return;\n            }\n\n            this.hoverIntent = true;\n            this.setOpenIndex(index);\n          }, HOVER_ENTER_TIMEOUT);\n        }\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n          hoverMoveTimeout = undefined;\n        }\n      });\n\n      $itemElement.mousemove(() => {\n        if (!this.hoverMode || this.hoverIntent) {\n          return;\n        }\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n        }\n        // Assume hover intent HOVER_MOVE_TIMEOUT after the mouse last moved (i.e. stopped moving).\n        hoverMoveTimeout = setTimeout(() => {\n          this.hoverIntent = true;\n          this.setOpenIndex(index);\n        }, HOVER_MOVE_TIMEOUT);\n      });\n\n      $itemElement.mouseleave(() => {\n        if (!this.hoverMode) {\n          return;\n        }\n\n        if (hoverTimeout) {\n          clearTimeout(hoverTimeout);\n        }\n        // Clear hover intent HOVER_LEAVE_TIMEOUT after the mouse leaves.\n        hoverTimeout = setTimeout(() => {\n          if (this.openIndex === index) {\n            this.hoverIntent = false;\n            this.setOpenIndex(-1);\n          }\n        }, HOVER_LEAVE_TIMEOUT);\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n          hoverMoveTimeout = undefined;\n        }\n      });\n\n      if (item.submenu && item.$toggle) {\n        item.$toggle.click(() => {\n          if (this.openIndex === index) {\n            this.setOpenIndex(-1);\n            item.focus();\n          } else {\n            this.setOpenIndex(index);\n            item.submenu.focusFirstItem();\n          }\n        });\n      }\n    });\n\n    // Move the roving tabindex to the first top level menu item.\n    if (this.focusContainer && this.items.length > 0) {\n      this.setActiveElement(this.items[0].$link);\n    }\n    this.setOrientation();\n    this.update();\n  }\n\n  /**\n   * Updates the roving tabindex with the given descendant.\n   */\n  setActiveElement($element) {\n    // Ensure we keep a roving tabindex on one of our descendants, otherwise we effectively become\n    // impossible to focus.\n    if (this.$element.has($element).length === 0) {\n      return;\n    }\n\n    if (this.$prevActiveElement) {\n      this.$prevActiveElement.attr('tabindex', '-1');\n    }\n\n    const $nextActiveElement = $element;\n    $nextActiveElement.attr('tabindex', '0');\n    this.$prevActiveElement = $nextActiveElement;\n  }\n\n  /**\n   * Automatically sets our orientation and updates the ARIA orientation attribute.\n   */\n  setOrientation() {\n    if (this.$element.is(':visible') && this.items.length >= 2) {\n      const firstOffset = this.items[0].$element.offset();\n      const secondOffset = this.items[1].$element.offset();\n      const dx = Math.abs(secondOffset.left - firstOffset.left);\n      const dy = Math.abs(secondOffset.top - firstOffset.top);\n\n      if (dx > dy) {\n        this.orientation = 'horizontal';\n      } else {\n        this.orientation = 'vertical';\n      }\n    } else if (this.role === 'menubar') {\n      this.orientation = 'horizontal';\n    } else {\n      this.orientation = 'vertical';\n    }\n\n    this.$element.attr('aria-orientation', this.orientation);\n  }\n\n  /**\n   * Automatically sets hover mode based on toggle button visibility.\n   */\n  setHoverMode() {\n    this.hoverMode = !this.items.some(item => item.$toggle && item.$toggle.is(':visible'));\n  }\n\n  /**\n   * Opens the given submenu or closes the currently opened submenu.\n   *\n   * @param {number} index\n   *   The index of the menu item whose submenu is open, or -1 if no submenu is open.\n   */\n  setOpenIndex(index) {\n    this.openIndex = index;\n    this.update();\n  }\n\n  /**\n   * Update the DOM based on state changes.\n   */\n  update() {\n    this.items.forEach((item, index) => {\n      item.setOpen(index === this.openIndex);\n    });\n  }\n\n  /**\n   * Helper to move focus to the first item in this menu.\n   */\n  focusFirstItem() {\n    if (this.items.length === 0) {\n      return;\n    }\n\n    this.items[0].focus();\n  }\n}\n\nexport default Menu;\n","import $ from 'jquery';\nimport Menu from './Menu';\n\n$.fn.slMenu = function slMenu() {\n  return new Menu(this);\n};\n\n$(document).ready(() => {\n  $('.sl-menu').slMenu();\n});\n"],"sourceRoot":""}