{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"jQuery\"","webpack:///./js/Menu.js","webpack:///./js/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","jQuery","ESC_KEY","END_KEY","HOME_KEY","LEFT_ARROW","UP_ARROW","RIGHT_ARROW","DOWN_ARROW","HOVER_ENTER_TIMEOUT","HOVER_MOVE_TIMEOUT","HOVER_LEAVE_TIMEOUT","lastSubmenuIndex","Menu_MenuItem","[object Object]","menu","$element","this","$link","find","first","wrap","open","attr","$submenuElement","length","submenuIndex","generateSubmenuId","submenu","role","focusContainer","addClass","$toggle","external_jQuery_default","insertAfter","text","update","setOpenIndex","removeClass","expanded","is","focus","js_Menu","options","hoverTimeout","hoverMoveTimeout","items","openIndex","hoverMode","hoverIntent","focusin","event","$activeElement","target","setActiveElement","setOrientation","focusout","setTimeout","document","activeElement","has","keydown","which","item","stopPropagation","preventDefault","mouseenter","setHoverMode","children","each","index","itemElement","$itemElement","push","openKey","orientation","closeKey","prevKey","nextKey","focusFirstItem","prevItem","nextItem","firstItem","lastItem","clearTimeout","undefined","mousemove","mouseleave","click","$prevActiveElement","$nextActiveElement","firstOffset","offset","secondOffset","dx","Math","abs","left","dy","top","some","forEach","setOpen","a","fn","slMenu","ready"],"mappings":"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","file":"menu.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = jQuery;","import $ from 'jquery';\n\nconst ESC_KEY = 27;\nconst END_KEY = 35;\nconst HOME_KEY = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\n\nconst HOVER_ENTER_TIMEOUT = 400;\nconst HOVER_MOVE_TIMEOUT = 40;\nconst HOVER_LEAVE_TIMEOUT = 400;\n\nlet lastSubmenuIndex = 0;\n\nfunction generateSubmenuId() {\n  const submenuIndex = lastSubmenuIndex + 1;\n  lastSubmenuIndex = submenuIndex;\n  return `sl-menu__submenu_${submenuIndex}`;\n}\n\nclass MenuItem {\n  constructor(menu, $element) {\n    this.menu = menu;\n    this.$element = $element;\n    this.$link = $element.find('a').first()\n      .wrap('<span class=\"sl-menu__link\"></span>');\n    this.open = false;\n\n    if (!this.$element.attr('role')) {\n      this.$element.attr('role', 'none');\n    }\n    if (!this.$link.attr('role')) {\n      this.$link.attr('role', 'menuitem');\n    }\n\n    const $submenuElement = $element.find('ul').first();\n    if ($submenuElement.length) {\n      if (!$submenuElement.attr('id')) {\n        $submenuElement.attr('id', generateSubmenuId());\n      }\n\n      this.submenu = new (menu.constructor)($submenuElement, {\n        role: 'menu',\n        focusContainer: false,\n      });\n      this.$element.addClass('sl-menu--has-submenu');\n      this.$link\n        .attr('aria-haspopup', 'menu')\n        .attr('aria-controls', $submenuElement.attr('id'));\n      this.$toggle = $('<button type=\"button\" class=\"sl-menu__toggle\">Toggle menu</button>')\n        .attr('aria-controls', $submenuElement.attr('id'))\n        .attr('tabindex', '-1')\n        .insertAfter(this.$link);\n      $submenuElement.addClass('sl-menu__submenu');\n      if (!$submenuElement.attr('aria-label')) {\n        $submenuElement.attr('aria-label', this.$link.text());\n      }\n    }\n\n    this.update();\n  }\n\n  setOpen(open) {\n    if (!this.submenu) {\n      return;\n    }\n\n    this.open = open;\n    // Recursively close any submenus.\n    this.submenu.setOpenIndex(-1);\n\n    this.update();\n  }\n\n  update() {\n    if (!this.submenu) {\n      return;\n    }\n\n    if (this.open) {\n      this.$element.removeClass('sl-menu--closed');\n      this.$element.addClass('sl-menu--open');\n    } else {\n      this.$element.removeClass('sl-menu--open');\n      this.$element.addClass('sl-menu--closed');\n    }\n\n    // Set aria-expanded based on how these classes affect styling. These classes may not have an\n    // effect depending on responsive breakpoints.\n    // TODO: Efficiently listen for window resize events and update this attribute when breakpoints\n    // change.\n    const expanded = this.submenu.$element.is(':visible') ? 'true' : 'false';\n    this.$link.attr('aria-expanded', expanded);\n    this.$toggle.attr('aria-expanded', expanded);\n  }\n\n  focus() {\n    this.$link.focus();\n  }\n}\n\nclass Menu {\n  constructor($element, options = {}) {\n    this.$element = $element;\n    // Indicates our ARIA role, typically menubar for the root menu and menu for submenus.\n    this.role = options.role || 'menubar';\n    // Determines whether we are the root menu and therefore the focus container that manages the\n    // roving tabindex.\n    this.focusContainer = typeof options.focusContainer === 'boolean' ? options.focusContainer : true;\n    this.items = [];\n    this.openIndex = -1;\n    this.hoverMode = true;\n    this.hoverIntent = false;\n\n    if (!this.$element.attr('role')) {\n      this.$element.attr('role', this.role);\n    }\n\n    // Triggered when any descendant receives focus.\n    $element.focusin((event) => {\n      // Update the roving tabindex.\n      if (this.focusContainer) {\n        const $activeElement = $(event.target);\n        this.setActiveElement($activeElement);\n      }\n\n      // Detect our orientation so our keyboard navigation make sense.\n      this.setOrientation();\n    });\n\n    if (this.focusContainer) {\n      // Triggered when any descendant loses focus.\n      $element.focusout(() => {\n        // We can't rely on event.relatedTarget in Cypress, and possibly certain browsers. Instead,\n        // use document.activeElement during the next iteration of the event loop.\n        setTimeout(() => {\n          if (!document.activeElement || $element.has(document.activeElement).length === 0) {\n            // Focus has moved outside of our focus container, so close all submenus and move the\n            // roving tabindex to the item corresponding to the last open top level submenu.\n            if (this.openIndex !== -1) {\n              this.setActiveElement(this.items[this.openIndex].$link);\n              this.setOpenIndex(-1);\n            }\n          }\n        });\n      });\n    }\n\n    // Close submenu when Escape key is pressed.\n    $element.keydown((event) => {\n      if (event.which === ESC_KEY && this.openIndex !== -1) {\n        const item = this.items[this.openIndex];\n        this.setOpenIndex(-1);\n        item.focus();\n\n        // Close one submenu at a time.\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    });\n\n    // Detect whether hover mode should be enabled.\n    $element.mouseenter(() => {\n      this.setHoverMode();\n    });\n\n    let hoverTimeout;\n    let hoverMoveTimeout;\n    $element.children('li').each((index, itemElement) => {\n      const $itemElement = $(itemElement);\n      const item = new MenuItem(this, $itemElement);\n      this.items.push(item);\n\n      // Set up all menu item links for roving tabindex.\n      item.$link.attr('tabindex', '-1');\n\n      $itemElement.keydown((event) => {\n        // Determine the keys for different behaviors based on our orientation.\n        const openKey = this.orientation === 'horizontal' ? DOWN_ARROW : RIGHT_ARROW;\n        const closeKey = this.orientation === 'horizontal' ? UP_ARROW : LEFT_ARROW;\n        const prevKey = this.orientation === 'horizontal' ? LEFT_ARROW : UP_ARROW;\n        const nextKey = this.orientation === 'horizontal' ? RIGHT_ARROW : DOWN_ARROW;\n\n        switch (event.which) {\n          case openKey:\n            if (item.submenu && this.openIndex !== index) {\n              this.setOpenIndex(index);\n              item.submenu.focusFirstItem();\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case closeKey:\n            if (item.submenu && this.openIndex === index) {\n              this.setOpenIndex(-1);\n              item.focus();\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case prevKey:\n            if (index > 0) {\n              // Determine whether this event bubbled up from an open submenu.\n              const bubbled = index === this.openIndex;\n\n              // Only allow bubbling from an open submenu on a horizontal menu.\n              if (!bubbled || this.orientation === 'horizontal') {\n                const prevItem = this.items[index - 1];\n\n                // If a submenu is open, try to open the previous item's submenu.\n                if (prevItem.submenu && this.openIndex !== -1) {\n                  this.setOpenIndex(index - 1);\n                  prevItem.submenu.focusFirstItem();\n                } else {\n                  this.setOpenIndex(-1);\n                  prevItem.focus();\n                }\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case nextKey:\n            if (index < this.items.length - 1) {\n              const nextItem = this.items[index + 1];\n\n              // If a submenu is open, try to open the previous item's submenu.\n              if (nextItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(index + 1);\n                nextItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                nextItem.focus();\n              }\n            }\n\n            // We're at the end of the menu, don't allow this to bubble and close the menu or\n            // something.\n            event.stopPropagation();\n            event.preventDefault();\n            break;\n\n          case HOME_KEY:\n            if (this.items.length > 0) {\n              const firstItem = this.items[0];\n\n              // If a submenu is open, try to open the first item's submenu.\n              if (firstItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(1);\n                firstItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                firstItem.focus();\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case END_KEY:\n            if (this.items.length > 0) {\n              const lastItem = this.items[this.items.length - 1];\n\n              // If a submenu is open, try to open the last item's submenu.\n              if (lastItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(this.items.length - 1);\n                lastItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                lastItem.focus();\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          default:\n            // Ignore all other keys.\n        }\n      });\n\n      $itemElement.mouseenter(() => {\n        if (!this.hoverMode) {\n          return;\n        }\n\n        if (hoverTimeout) {\n          clearTimeout(hoverTimeout);\n          hoverTimeout = undefined;\n        }\n        if (this.hoverIntent) {\n          this.setOpenIndex(index);\n        } else {\n          // Assume hover intent HOVER_ENTER_TIMEOUT after the mouse enters.\n          hoverTimeout = setTimeout(() => {\n            if (!this.hoverMode) {\n              return;\n            }\n\n            this.hoverIntent = true;\n            this.setOpenIndex(index);\n          }, HOVER_ENTER_TIMEOUT);\n        }\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n          hoverMoveTimeout = undefined;\n        }\n      });\n\n      $itemElement.mousemove(() => {\n        if (!this.hoverMode || this.hoverIntent) {\n          return;\n        }\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n        }\n        // Assume hover intent HOVER_MOVE_TIMEOUT after the mouse last moved (i.e. stopped moving).\n        hoverMoveTimeout = setTimeout(() => {\n          this.hoverIntent = true;\n          this.setOpenIndex(index);\n        }, HOVER_MOVE_TIMEOUT);\n      });\n\n      $itemElement.mouseleave(() => {\n        if (!this.hoverMode) {\n          return;\n        }\n\n        if (hoverTimeout) {\n          clearTimeout(hoverTimeout);\n        }\n        // Clear hover intent HOVER_LEAVE_TIMEOUT after the mouse leaves.\n        hoverTimeout = setTimeout(() => {\n          if (this.openIndex === index) {\n            this.hoverIntent = false;\n            this.setOpenIndex(-1);\n          }\n        }, HOVER_LEAVE_TIMEOUT);\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n          hoverMoveTimeout = undefined;\n        }\n      });\n\n      if (item.submenu && item.$toggle) {\n        item.$toggle.click(() => {\n          if (this.openIndex === index) {\n            this.setOpenIndex(-1);\n            item.focus();\n          } else {\n            this.setOpenIndex(index);\n            item.submenu.focusFirstItem();\n          }\n        });\n      }\n    });\n\n    // Move the roving tabindex to the first top level menu item.\n    if (this.focusContainer && this.items.length > 0) {\n      this.setActiveElement(this.items[0].$link);\n    }\n    this.setOrientation();\n    this.update();\n  }\n\n  /**\n   * Updates the roving tabindex with the given descendant.\n   */\n  setActiveElement($element) {\n    // Ensure we keep a roving tabindex on one of our descendants, otherwise we effectively become\n    // impossible to focus.\n    if (this.$element.has($element).length === 0) {\n      return;\n    }\n\n    if (this.$prevActiveElement) {\n      this.$prevActiveElement.attr('tabindex', '-1');\n    }\n\n    const $nextActiveElement = $element;\n    $nextActiveElement.attr('tabindex', '0');\n    this.$prevActiveElement = $nextActiveElement;\n  }\n\n  /**\n   * Automatically sets our orientation and updates the ARIA orientation attribute.\n   */\n  setOrientation() {\n    if (this.$element.is(':visible') && this.items.length >= 2) {\n      const firstOffset = this.items[0].$element.offset();\n      const secondOffset = this.items[1].$element.offset();\n      const dx = Math.abs(secondOffset.left - firstOffset.left);\n      const dy = Math.abs(secondOffset.top - firstOffset.top);\n\n      if (dx > dy) {\n        this.orientation = 'horizontal';\n      } else {\n        this.orientation = 'vertical';\n      }\n    } else if (this.role === 'menubar') {\n      this.orientation = 'horizontal';\n    } else {\n      this.orientation = 'vertical';\n    }\n\n    this.$element.attr('aria-orientation', this.orientation);\n  }\n\n  /**\n   * Automatically sets hover mode based on toggle button visibility.\n   */\n  setHoverMode() {\n    this.hoverMode = !this.items.some(item => item.$toggle && item.$toggle.is(':visible'));\n  }\n\n  /**\n   * Opens the given submenu or closes the currently opened submenu.\n   *\n   * @param {number} index\n   *   The index of the menu item whose submenu is open, or -1 if no submenu is open.\n   */\n  setOpenIndex(index) {\n    this.openIndex = index;\n    this.update();\n  }\n\n  /**\n   * Update the DOM based on state changes.\n   */\n  update() {\n    this.items.forEach((item, index) => {\n      item.setOpen(index === this.openIndex);\n    });\n  }\n\n  /**\n   * Helper to move focus to the first item in this menu.\n   */\n  focusFirstItem() {\n    if (this.items.length === 0) {\n      return;\n    }\n\n    this.items[0].focus();\n  }\n}\n\nexport default Menu;\n","import $ from 'jquery';\nimport Menu from './Menu';\n\n$.fn.slMenu = function slMenu() {\n  return new Menu(this);\n};\n\n$(document).ready(() => {\n  $('.sl-menu').slMenu();\n});\n"],"sourceRoot":""}